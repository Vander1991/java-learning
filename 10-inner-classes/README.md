# 10-内部类：
		将一个类的定义放在另一个类的定义内部，称为内部类
		匿名内部类的实例初始化实际效果相当于其构造器（匿名内部类没有名字，所以没有构造器）
		匿名内部类与正规的继承相比受限制，它可以扩展类也可以实现接口，但是二者不可兼得，实现接口也只能
	实现一个
		一个内部类被嵌套多少层并不重要，它能透明地访问所有它所嵌入的外围类的所有成员
		为什么需要内部类：
			如果只是需要一个对接口的引用，直接通过外围类实现这个接口就好了，但是外围类如果用到了接口
		的一些实现，然后他又想实现这个接口，这时候就只能通过内部类实现了。
			每个内部类都能独立地继承自一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）
		实现，对于内部类是没有影响的
			内部类有效地实现了“多重继承”，它允许继承讴歌非接口类型（类或抽象类）
			使用内部类可以获得以下四个特性：
				1、内部类可以有多个实例，每个实例都有自己的状态信息，并且与外围类对象的信息相互独立
				2、在单个外围类中，可以让多个内部类以不同的方式实现同一个接口，或继承同一个类。
				3、创建内部类对象的时刻并不依赖于外围类对象的创建
				4、内部类并没有令人迷惑的is-a关系，他就是一个独立的实体（例子见Practice22）
		闭包（closure）是一个可调用的对象，它记录了一些信息，这些信息来自于创建它的作用域，通过这
		个定义，可以看出内部类是面向对象的闭包，因为它不仅包含外围类对象（创建内部类的作用域）的信息
		还自动拥有一个指向此外围类对象的引用，在此作用域内，内部类有权操作所有的成员，包括private
		成员
		内部类标志符：
			每个类都有一个class文件LocalInnerClass.java为例子
				Counter.class
				LocalInnerClass$1.class（说明是第一个匿名内部类）
				LocalInnerClass$1LocalCounter.class
				LocalInnerClass.class
			如果内部类是嵌套在别的内部类之中的，只需直接将它们的名字加在其外围类标识符与"$"的后面
# 总结：
	使用内部类条件：
		1、需要控制客户端对类的访问的时候
		2、像工厂模式那样为了达到更一致的封装
		3、为了实现多重继承

