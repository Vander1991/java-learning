# 12-通过异常处理错误：
		抛出异常后，首先将使用new在堆上创建异常对象，然后当前的执行路径被终止，并且从当前环境中弹出对异
	常对象的引用，此时，异常处理机制接管程序，并开始寻找一个恰当的地方来继续执行程序，并开始寻找一个恰当
	的地方来继续执行程序，这个恰当的地方就是异常处理程序，它的任务是将程序从错误状态中恢复以使程序能要么
	换种方式运行，要么继续运行下去。
		异常的基本概念是用名称代表发生的问题，名称能够望文知章。
		终止与恢复
			终止模型：这种模型假设错误非常关键，一旦异常被抛出就表明已无法挽回，不能回来继续执行
			恢复模型：异常处理程序的工作是修正错误，然后尝试调用出问题的方法，并认为第二次能成功，如果
		想要用这种模型，那在遇到错误的时候就不能抛出异常，而是调用方法来修正，或者把try块放在while循环
		里，不断地去try，直到结果满意为止。
			尽管恢复模型很吸引，但是不实用，因为它可能会导致耦合；恢复性处理程序需要了解异常抛出的地点
		势必包含依赖于抛出位置的非通用行代码，这增加了代码编写和维护的难度，对于大型程序更是如此。
	异常说明
		Java鼓励使用者把方法可能会抛出的异常告知使用此方法的客户端程序员，它是的调用者能确切知道写什么
	样的代码可以捕获所有潜在的异常。由于客户端程序员一般拿不到方法的源码，所以Java提供了相应的语法，使
	你能以礼拜的方式告知客户端程序员某个方法可能会抛出的异常类型，然后客户端程序员再做相应的处理。
		将方法声明成抛出某个异常，但实际上不这么做，编译器相信这个声明，并强制此方法的用户像真的会抛出
	异常那样使用方法，这样做的好处是先让异常占个位置，以后有需要的时候再抛出，客户端程序就不用修改了。
	在定义抽象类和接口时这种能力很重要，这样派生类或接口实现就能够抛出这些预先声明的异常了。
	捕获异常：
		Exception是所有异常类的基类，所以它不会包含太多具体的信息，不过可以调用它从其基类Throwable
	继承的方法：String getMessage()、String getLocalizedMessage()
		用来获取详细信息，或用本地语言表示详细信息：String toString()
		返回队Throwable的简单描述，要是有详细信息，也会把它包含在内：
			void printStackTrace()
			void printStackTrace(PrintStream)
			void printStackTrace(PrintWriter)
			这些都是打印调用栈的，它显示了“把你带到异常抛出地点”的方法调用序列
		以下是用于Throwable对象的内部记录栈帧的当前状态，这些程序重新抛出异常或错误时很有用
			Throwable fillInStackTrace()
			此外，也可以使用Throwable从其基类Object继承的方法，对于异常而言，getClass()也许是很好
		用的方法，它将返回一个表示此对象类型的对象。可以使用getName()获取这个对象包含报信息的名称，用
		getSimpleName()获取不包含包信息的名称
		不必清理前一个异常对象而担心，他们都是new在堆上创建的对象，所以垃圾回收器会自动把它们清理掉
	Java标准异常
		Throwable对象分为两类：Error（编译时和系统错误，一般不关心）和Exception（可以抛出的异常）
		RunTimeException-运行时异常
			属于此类异常 有很多，它们自动被JVM抛出，不必在异常说明中列出它们，它们称为“不受检查异常”，
		这种异常属于错误，将被自动补货，就不用你亲自动手了，要是自己去检查RunTimeException，代码
		就会显得很凌乱
			只能在代码中忽略RuntimeException类型的异常，其他类型的异常处理是编译器强制实施的，
			究其原因，RuntimeException代表的是编程错误。
		值得注意：
			不应该把Java的异常处理机制当成单一用途的工具，虽然它被设计用来处理一些烦人的运行时错误，
		这些错误往往是由代码控制能力之外的因素导致的；然而，它对于发现某些编译器无法检测到的编程错误，
		也非常重要。（例如像ArrayIndexOutOfBoundsException，在这种情况下使用异常能对调试带来好处）
	finally
		当要把除内存之外的资源（打开的文件、网络连接等等）恢复到它们的初始状态时，就要用到finally
	异常的限制：
		在继承过程中，编译器会对异常说明做强制要求，单异常说明本身并不属于方法类型的一部分，方法类型
	是由方法名字和参数类型组成的，不能基于异常说明来重载方法。此外，一个出现在基类方法的异常说明中的
	异常，不一定会出现在派生类方法的异常说明里。这点同继承的规则明显不同，在继承中，基类的方法必须出
	现在派生类里，换句话说，在继承和覆盖的过程中，某个特定方法的“异常说明你的接口”不是变大了而是变小
	了-这恰好和类接口在继承时的情形相反。
# 总结：
		
	
