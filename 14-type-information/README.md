# 14-类型信息：
	运行时类型信息使得你可以在程序运行时发现和使用类型信息
	RTTI：
		即：运行时，识别一个对象的类型
		怎么理解？假设现在有父类Shape，子类Triangle、Square、Circle，将他们放入
	容器中List<Shape>，当从容器中取出这些子类的时候，并不知道是Circle还是Triangle还是Square，只知道它是Shape，
	所以这里需要用到RTTI才能在运行时查询到某个Shape的引用所指向的对象的确切类型，然后进行特定的操作。
	Java如何让我们在运行时识别对象和类的信息，主要有两种方式：
		1、“传统的”RTTI，它假定编译时已经知道了所有的类型；
		2、反射机制，允许在运行时发现和使用了类的信息
	Class对象
		每个类都有一个Class对象（被保存在同名的.class文件中，所有的Class对象都属于Class类），生成这个对象运行这个程序需要用到JVM的
		“类加载器”
	类加载器
		实际上是一条类加载器链，但是它只有一个原生类加载器，它是JVM实现的一部分。原生类加载器加载的是可信类，
	包括Java API类，它们通常是从本地盘加载的。有特殊需求也可以挂接额外的类加载器到这条链上。
		所有的类在第一次使用时，动态加载到JVM中，当程序创建第一个对类的静态成员的引用时，就会加载这个类。
	这个证明构造器也是类的静态方法，几时在构造器之前并没有使用static关键字。因此，使用new 创建类的新对象
	也会被当成对列的静态成员的引用。因此，Java程序在它开始运行之前并非被完全加载，其各个部分是在必要时才
	加载，它是动态加载语言，跟C++这种静态加载语言不同。
		类加载器首先检查这个类的Class对象是否已经加载，如果尚未加载，默认的类加载器就会根据类名查找.class
	文件（例如，某个附加类加载器可能会在数据库中查找字节码）。在这个类的字节码被加载时，它们会接受验证，以确保
	其没有被破坏，并且不包含不良Java代码（这是Java中用于安全防范目的的措施之一）
		一旦某个类的Class对象被载入内存，它就被用来创建这个类的所有对象。
	类字面常量
		当使用.class形式创建对Class对象的引用时，不会自动地初始化该Class对象
		为了使用类而做的准备有三步：
			1、加载：这是由类加载器执行的，该步骤将查找字节码（通常在classpath所指定的路径中查找，但这并非是必须的），并从这些字节
			码中创建一个Class对象
			2、连接：在链接阶段将验证类中的字节码，为静态域分配存储空间，并且如果必须的话，将解析这个类创建的对其他类的所有引用。
			3、初始化：如果该类有超类，则对其初始化，执行静态初始化器和静态初始化块。
			初始化被延迟到了对静态方法（构造器是隐式静态的）或者非常数静态域进行首次引用时才执行
	泛化的Class引用
		Class引用总是指向某个Class对象，它可以制造类的实例，并包含可作用于这些实例的所有方法代码。它还包含该类的静态成员，因此Class
	引用表示的是它所指向的对象的确切类型，而该对象便是Class类的一个对象
	类型转换前先做检查
		RTTI形式：
		1、传统的类型转换，由RTTI确保类型转换的正确性，如果执行错误的类型转换会抛出ClassCastException
		2、代表对象的类型的Class对象。通过查询Class对象可以获取运行时所需的信息
		3、使用Instanceof来在运行时识别对象类型
	反射：
			RTTI虽然能告诉你某个对象的确切类型，但是它有一个限制，就是这个类型在编译时必须已知，
		这样RTTI才能识别它，换句话说编译器必须知道所有要通过RTTI来处理的类
			人们想要在运行时获取类的信息的另一个动机，便是希望提供在跨网络的远程平台上创建和运行
		对象的能力，这就是远程方法调用（RMI），它允许一个Java程序将对象分布到多台机器上。
			Class类与java.lang.reflect类库一起对反射的概念进行了支持，该类库包含了Field、
		Method以及Constructor类（每个类都实现了Member接口）。这些类型的对象是由JVM在运行时
		创建的，用以表示未知类里对应的成员。这样你就可以使用Constructor创建新的对象，用get()和
		set()方法读取和修改与Field对象关联的字段，用invoke()方法调用与Method对象关联的方法。
		另外，还可以调用getFields(),getMethods(),getConstructors等便利的方法，以返回表示
		字段、方法以及构造器的对象的数组，这样，匿名对象的类信息就能在运行时被完全确定下来，而在
		编译时不需要知道任何事情。
			要认识到反射机制并没有什么神奇之处，当通过反射与一个未知类型的对象打交道时，JVM只是简
		单地检查这个对象，看它属于哪个特定的类（就像RTTI那样）。在用它做其他事情前必须先加载那个类
		的Class对象。因此，那个类的.class文件对于JVM来说必须是可获取的：要么在本机上，要么通过网
		络取得。所以RTTI与反射真正的区别在于，对RTTI来说，编译器在编译时打开和检查.class文件。
		（换句话说，就是用“普通”方式调用对象的所有方法）而对反射机制来说，.class文件在编译时不可
		获取，所以在运行时打开和检查.class文件。
	代理：
			在任何时刻，只要你想要将额外的操作从“实际”对象中分离到不同的地方，特别是当你希望能够很
		容易地作出修改，从没有使用额外操作转为使用这些操作，或者反过来时，代理就显得很有用（设计模式
		的关键是封装修改-因此你需要修改事务以证明这种模式的正确性）
	空对象：
			当你使用内置的null表示缺少对象时，在每次使用引用时都必须测试其是否为null。问题在于null
		除了在你试图用它执行任何操作来产生NullPointerException之外，它自己没有其他任何行为。有时候
		引入“空对象”的思想会很有用，他可以接收传递给它的所代表的对象的信息，但是将返回表示为实际上并
		不存在任何“真实”对象的值。通过这种方式，我们假设所有对象都是有效的，不必浪费编程精力去检查null
			尽管想象一种可以自动为我们创建空对象的编程语言显得很有趣，但是实际上，到处使用空对象没有意义
		有时检查null就可以了，有时你可以合理地假设你根本不会遇到null，有时甚至通过NullPointerException
		来探测异常也可以接受。空对象最有用支出在于它更靠近数据，因为对象表示的是问题空间内的实体。
			有个例子：许多系统都有一个Person类，而在代码中，有很多情况是你没有一个实际的人（或者你有，但是
		没有全部具体信息），因此，通常你会使用一个null引用并测试它。与此不同，我们可以使用空对象。但是
		即使空对象可以响应“实际”对象可以响应所有信息，你仍需要某种方式去测试其是否为空。要达到这个目的，
		最简单的方式 是创建一个标记接口 public interface Null{},这使得instanceof可以探测空对象
		
			
		
# 总结：
	
	
