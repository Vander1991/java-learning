# 14-类型信息：
	运行时类型信息使得你可以在程序运行时发现和使用类型信息
	RTTI：
		即：运行时，识别一个对象的类型
		怎么理解？假设现在有父类Shape，子类Triangle、Square、Circle，将他们放入
	容器中List<Shape>，当从容器中取出这些子类的时候，并不知道是Circle还是Triangle还是Square，只知道它是Shape，
	所以这里需要用到RTTI才能在运行时查询到某个Shape的引用所指向的对象的确切类型，然后进行特定的操作。
	Java如何让我们在运行时识别对象和类的信息，主要有两种方式：
		1、“传统的”RTTI，它假定编译时已经知道了所有的类型；
		2、反射机制，允许在运行时发现和使用了类的信息
	Class对象
		每个类都有一个Class对象（被保存在同名的.class文件中，所有的Class对象都属于Class类），生成这个对象运行这个程序需要用到JVM的
		“类加载器”
	类加载器
		实际上是一条类加载器链，但是它只有一个原生类加载器，它是JVM实现的一部分。原生类加载器加载的是可信类，
	包括Java API类，它们通常是从本地盘加载的。有特殊需求也可以挂接额外的类加载器到这条链上。
		所有的类在第一次使用时，动态加载到JVM中，当程序创建第一个对类的静态成员的引用时，就会加载这个类。
	这个证明构造器也是类的静态方法，几时在构造器之前并没有使用static关键字。因此，使用new 创建类的新对象
	也会被当成对列的静态成员的引用。因此，Java程序在它开始运行之前并非被完全加载，其各个部分是在必要时才
	加载，它是动态加载语言，跟C++这种静态加载语言不同。
		类加载器首先检查这个类的Class对象是否已经加载，如果尚未加载，默认的类加载器就会根据类名查找.class
	文件（例如，某个附加类加载器可能会在数据库中查找字节码）。在这个类的字节码被加载时，它们会接受验证，以确保
	其没有被破坏，并且不包含不良Java代码（这是Java中用于安全防范目的的措施之一）
		一旦某个类的Class对象被载入内存，它就被用来创建这个类的所有对象。
	类字面常量
		当使用.class形式创建对Class对象的引用时，不会自动地初始化该Class对象
		为了使用类而做的准备有三步：
			1、加载：这是由类加载器执行的，该步骤将查找字节码（通常在classpath所指定的路径中查找，但这并非是必须的），并从这些字节
			码中创建一个Class对象
			2、连接：在链接阶段将验证类中的字节码，为静态域分配存储空间，并且如果必须的话，将解析这个类创建的对其他类的所有引用。
			3、初始化：如果该类有超类，则对其初始化，执行静态初始化器和静态初始化块。
			初始化被延迟到了对静态方法（构造器是隐式静态的）或者非常数静态域进行首次引用时才执行
	泛化的Class引用
		Class引用总是指向某个Class对象，它可以制造类的实例，并包含可作用于这些实例的所有方法代码。它还包含该类的静态成员，因此Class
	引用表示的是它所指向的对象的确切类型，而该对象便是Class类的一个对象
	类型转换前先做检查
		RTTI形式：
		1、传统的类型转换，右RTTI确保类型转换的正确性，如果执行错误的类型转换会抛出ClassCastException
		2、代表对象的类型的Class对象。通过查询Class对象可以获取运行时所需的信息
		3、使用Instanceof来在运行时识别对象类型
# 总结：
	Java对字符串操作的支持已经相当完善，在处理String的时候要注意如何在恰当的地方使用StringBuilder
	
