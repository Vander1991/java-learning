# 15-泛型：
		泛型实现了参数化类型的概念，使代码可以应用于多种类型。泛型在编程语言中出现的最初目的是希望类或方法能够具备
	最广泛的表达能力。	如何做到这一点呢，正是通过解耦类或方法与使用的类型之间的约束。后续会看到Java的泛型并没有这
	么高的追求，实际上，你可能会质疑Java中的泛型是否适合用来描述这一功能。
		我们一般会使用容器来存放对象，我们希望容器能够同时持有多种类型的对象。但是通常，我们只用容器来存储一种类型
	的对象。泛型的主要目的之一就是用来指定容器要持有什么类型的对象，而且由编译器来保证类型的正确性。
	元组类库：
		元组、数据传送对象、信使：
			将一组对象直接打包存储于其中的一个单一对象。这个容器对象允许读取其中元素，但是不允许向其中存放新的
		对象。元组可以具有任意长度，可以有不同类型的对象，但是我们希望能够为每个对象指明其类型，并且从容器中读取
		出来时，能够得到正确的类型。要处理不同长度的问题，我们需要创建多个不同的元组。
	泛型方法：
		是否拥有泛型方法与其所在的类是否是泛型没有关系，无论何时，只要你能做到，你就应该尽量使用泛型方法，也就是说
	如果使用泛型方法可以取代整个类泛型化，那么就应该只使用泛型方法，另外，对于一个static方法而言，无法访问泛型的
	类型参数，所以如果static需要使用泛型能力，就必须使其成为泛型方法。
		当使用泛型类时，必须在创建对象的时候指定类型参数的值，而使用泛型方法的时候，通常不必指明参数类型，因为编
	译器会为我们找出具体的类型，这称为类型参数推断
	擦除：
		在泛型代码内部，无法获得任何有关泛型参数类型的信息
		Java泛型是使用擦除来实现的，这意味着当你在使用泛型的时候，任何具体的类型信息都被擦除了，你唯一知道的就是
	你在使用一个对象。因此List<String>和List<Integer>在运行时事实上是相同的类型。这两种形式都被擦除成他们的
	“原生”类型，即List。
		边界<T extends HasF>声明T必须具有类型HasF或者从HasF导出的类型。我们可以说泛型类型参数将擦除到它的第
	一个边界（它可能会有很多个边界）我们还提到了类型参数的擦除，编译器实际上会把类型参数替换为它的擦除。
		在基于擦除的实现中，泛型类型被当作第二类类型处理，即不能在某些重要的上下文环境中使用的类型。泛型类型只有
	在静态类型检查期间才出现，在此之后，程序中的所有泛型类型都将被擦除，替换为他们的非泛型上界。例如，List<T>这样
	的类型注解将被擦除为List，而普通的类型变量在未指定边界的情况下将被擦除为Object。
		兼容迁移性：擦除的核心动机是它使得泛化的客户端可以用非泛化的类库来使用，反之亦然。
		由于Java泛型不仅必须支持向后兼容，并保持继续其之前的含义，而且还要支持迁移兼容性，因此Java的设计者们认为
	擦除是唯一可行的解决方案。通过允许非泛型代码和泛型代码共存，擦除使得这种向着泛型的迁移成为可能。
		擦除的主要理由是从非泛化代码到泛化代码的转变过程，以及在不破坏现有类库的情况下，将泛型融入	Java语言。擦除
	使得现有的非泛型客户端代码能够在不改变的情况下继续使用，直至客户端准备好用泛型重写这些代码。
		擦除的问题：
			泛型不能用于显式地引用运行时类型的操作之中，例如转型、instanceof操作和new表达式。
	通配符：
		读的时候用协变<? extends T>，写的时候用逆变<? super T>
	
# 总结：
	
