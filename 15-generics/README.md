# 15-泛型：
		泛型实现了参数化类型的概念，使代码可以应用于多种类型。泛型在编程语言中出现的最初目的是希望类或方法能够具备
	最广泛的表达能力。	如何做到这一点呢，正是通过解耦类或方法与使用的类型之间的约束。后续会看到Java的泛型并没有这
	么高的追求，实际上，你可能会质疑Java中的泛型是否适合用来描述这一功能。
		我们一般会使用容器来存放对象，我们希望容器能够同时持有多种类型的对象。但是通常，我们只用容器来存储一种类型
	的对象。泛型的主要目的之一就是用来指定容器要持有什么类型的对象，而且由编译器来保证类型的正确性。
	元组类库：
		元组、数据传送对象、信使：
			将一组对象直接打包存储于其中的一个单一对象。这个容器对象允许读取其中元素，但是不允许向其中存放新的
		对象。元组可以具有任意长度，可以有不同类型的对象，但是我们希望能够为每个对象指明其类型，并且从容器中读取
		出来时，能够得到正确的类型。要处理不同长度的问题，我们需要创建多个不同的元组。
	泛型方法：
		是否拥有泛型方法与其所在的类是否是泛型没有关系，无论何时，只要你能做到，你就应该尽量使用泛型方法，也就是说
	如果使用泛型方法可以取代整个类泛型化，那么就应该只使用泛型方法，另外，对于一个static方法而言，无法访问泛型的
	类型参数，所以如果static需要使用泛型能力，就必须使其成为泛型方法。
		当使用泛型类时，必须在创建对象的时候指定类型参数的值，而使用泛型方法的时候，通常不必指明参数类型，因为编
	译器会为我们找出具体的类型，这称为类型参数推断
	擦除：
		在泛型代码内部，无法获得任何有关泛型参数类型的信息
		Java泛型是使用擦除来实现的，这意味着当你在使用泛型的时候，任何具体的类型信息都被擦除了，你唯一知道的就是
	你在使用一个对象。因此List<String>和List<Integer>在运行时事实上是相同的类型。这两种形式都被擦除成他们的
	“原生”类型，即List。
		边界<T extends HasF>声明T必须具有类型HasF或者从HasF导出的类型。我们可以说泛型类型参数将擦除到它的第
	一个边界（它可能会有很多个边界）我们还提到了类型参数的擦除，编译器实际上会把类型参数替换为它的擦除。
		在基于擦除的实现中，泛型类型被当作第二类类型处理，即不能在某些重要的上下文环境中使用的类型。泛型类型只有
	在静态类型检查期间才出现，在此之后，程序中的所有泛型类型都将被擦除，替换为他们的非泛型上界。例如，List<T>这样
	的类型注解将被擦除为List，而普通的类型变量在未指定边界的情况下将被擦除为Object。
		兼容迁移性：擦除的核心动机是它使得泛化的客户端可以用非泛化的类库来使用，反之亦然。
		由于Java泛型不仅必须支持向后兼容，并保持继续其之前的含义，而且还要支持迁移兼容性，因此Java的设计者们认为
	擦除是唯一可行的解决方案。通过允许非泛型代码和泛型代码共存，擦除使得这种向着泛型的迁移成为可能。
		擦除的主要理由是从非泛化代码到泛化代码的转变过程，以及在不破坏现有类库的情况下，将泛型融入	Java语言。擦除
	使得现有的非泛型客户端代码能够在不改变的情况下继续使用，直至客户端准备好用泛型重写这些代码。
		擦除的问题：
			泛型不能用于显式地引用运行时类型的操作之中，例如转型、instanceof操作和new表达式。
	通配符：
		数组对象可以保留有关它们包含的对象类型的规则。
		List<? extends Fruit> flist = Arrays.asList(new Apple())-》支持Fruit f = flist.get(0);
			如果我们指定泛型参数为 <? extends Fruit> 时，add() 方法的参数变为 ? extends Fruit，编译器无法
		判断这个参数接受的到底是 Fruit 的哪种类型，所以它不会接受任何类型。
		读的时候用协变<? extends T>，写的时候用逆变<? super T>
	泛型的问题：
		1、任何基本类型都不能作为类型参数
		2、一个类不能实现同一个泛型接口的两种变体，由于擦除的原因，这两个变体会成为相同的接口
		3、使用带有泛型类参数的转型或instanceof不会有任何效果
	自限定的类型：
		class Subtype extends BasicHolder<Subtype>这样是允许的，相当于可以限定其内部T的范围是Subtype及其子类
	混型：
		混型最基本的概念是混合多个类的能力，以产生一个可以表示混型中所有类型的类，这往往是你最后的手段，它将使组装多个
	类变得简单易行。混型的价值之一是它们可以将特性和行为一致地应用于多个类之上。
		混型在Java中有三种实现方式：1、使用接口	2、使用装饰者模式（局限解决）
	潜在类型机制
			泛型代码典型地将在泛型类型上调用少量方法，而具有潜在类型机制的语言只要求实现某个方法子类，而不是某个特定类
		或接口，从而放松了这种限制（并且可以产生更加泛化的代码），正因如此，潜在类型机制使得你可以横跨类继承结构，调用
		不属于某个公共接口的方法。因此，实际上一段代码可以声明：“我不关心你是什么类型，只要你可以speak()和sit()即可”
		由于不要求具体类型，因此代码就可以更加泛化。C++跟Python都能支持这种方式，但是Java没有对这种特性进行支持，如果
		视图使用C++或Python的这种方式，就会被强制要求使用一个类或接口，并在边界表达式中指定它。
			潜在类型机制是一种代码组织和复用机制，有了它编写出的代码相对于没有它编写出的代码，能够更容易地复用。代码组织和
		复用是所有计算机编程的基本手段：编写一次，多次使用，并在一个位置保存代码。因为我并未被要求命名我的代码要操作于
		其上的确切接口，所以有了潜在类型机制，就可以编写更少的代码，更容易地将其应用于多个地方
	潜在类型机制的补偿：
		虽然Java不支持潜在类型机制，但是并不意味着有界泛型代码不能再不同的类型层次结构之间应用，只是需要些额外的努力
		可以使用以下方式：
			1、反射
# 总结：
	
