# 16-数组：
	数组为何特殊
		数组与其他种类的容器之间的区别有三方面：效率、类型和保存基本类型的能力
		在Java中数组是一种效率最高的存储和随机访问对象引用序列的方式。数组就是一个简单的线性序列，使得元素访问非常快速。
	但是这种速度所付出的代价是数组对象的大小被固定，并且在生命周期内不可改变。有了泛型之后，容器可以指定并检查它们所持有对象
	的类型，并且有了自动包装机制，容器看起来就能够持有基本类型了。所以数组仅剩下的优势就是效率。
	
	数组是第一级对象
		length表示的是数组能够容纳多少元素，而不是数组确切有多少元素
		对象数组和基本类型数组唯一的区别是对象数组保存的是引用，基本类型数组直接保存基本类型的值。
	
	返回一个数组
			写一个方法返回一个数组在C++或者C中是有困难的，它们返回的是一个数组指针，这会让数组的生命周期难以控制并且容易造成
		内存泄露，但是在Java中你仅需要返回就行，他就会一直存在到你使用完为止，垃圾回收器会清理掉它。
		
	数组与泛型
			数组与泛型不能很好的结合，你不能实例化具有参数化类型的数组，因为擦除会移除参数类型信息，而数组必须知道它们所持有
		的确切类型，以强制保证类型安全。但是可以参数化数组本身的类型。如ParameterizedArrayType.java中所示。编译器虽然不
		让你实例化泛型数组，但是却可以创建对这种数组的引用：List<String>[] ls，尽管不能创建实际的持有泛型的数组对象，但是
		你可以创建非泛型的数组然后将其转型，件ArrayOfGenerics.java。
	
	Arrays实用功能
			System.arraycopy()可以进行数组的复制操作，但是其复制只是浅复制，只是复制对象的引用而不是对象本身的拷贝，并且
		不会执行自动包装盒自动拆包，两个数组必须是确切的类型。
			Arrays.equals()要求两个数组的元素个数要相等，并且对应的位置也要相等
			程序设计的基本目标是将保持不变的事物与会发生改变的事物相分离，所以JDK将排序的算法固定下来，变化的就是各种对象的
		比较方式。Java中有两种方式来提供比较功能，第一种是实现java.lang.Comparable接口，使你的类具有“天生的”比较能力、假
		设有人给你的类实现了Comparable，但是不符合你的要求，要解决这个问题可以使用第二种方式，创建一个实现了Comparator接口
		的单独的类，详细见Reverse.java和ComparatorTest.java。在Java类库中的排序算法针对正排序的特殊类型进行了优化——针对
		基本类型设计的“快速排序”，以及针对对象设计“稳定归并排序”。
			Arrays.binarySearch()执行快速查找。如果要对未排序的数组使用binarySearch()，那么将产生不可预料的结果。如果需
		要对没有重复元素的数组排序，可以使用TreeSet（保持排序顺序），或者LinkedHashSet（保持插入顺序）。如果使用Comparator
		排序某个对象数组（基本类型数组无法使用Comparator进行排序），在使用binarySearch()时必须提供同样的Comparator（使用
		binarySearch的重载版本）
	
# 总结：
		在Java早期版本中，对于容器的支持比较少，Java对尺寸固定的低级数组提供了适度的支持，这种数组强调的是性能而不是灵活性。后
	期有了额外的自动包装和泛型，在容器中持有基本类型也简单很多，泛型可以产生类型安全的容器，数组除了在性能上保有一点优势外，就没
	别的优势了。当你使用最近的JDK版本编程时，应该优先使用容器而不是数组，除非证明容器的性能不够。

	
