# 21-并发：
	前言：
		为并发的基本知识打下坚实的基础，从而能够理解其概念并编写出合理的多线程程序。
	
	并发的多面性：
		用并发解决的问题大体上可以分为“速度”和“设计可管理性”两种。
		更快的执行：
			并发通常是提高运行在单处理器上的程序的性能。在单处理器上运行的并发程序开销确实应该比该程序的所有部分都顺序执行的
		开销大，因为其中增加了所谓“上下文切换的代价”（从一个任务切换到另一个任务）。
			实现并发最直接的方式是在操作系统级别使用进程，进程是运行在它自己的地址空间内的自包容程序。多任务操作系统可以通过
		周期性地将CPU从一个进程切换到另一个进程来实现同时运行多个进程（程序），尽管它们总是歇歇停停的。操作系统一般会把进程
		隔离开。与此相反的是，像Java所使用的这种并发系统会共享诸如内存和I/O这样的资源，因此编写多线程程序最基本的困难在于在
		协调不同线程驱动的任务之间对这些资源的使用，以使得这些资源不会同时被多个任务访问。
			某些编程语言被设计为可以将并发任务彼此隔离，这些语言通常被称为函数型语言，其中每个函数调用都不会产生任何副作用，
		因此可以当做独立的任务来驱动（如Erlang）。
			Java采用更加传统的方式，在顺序性语言的基础上提供对线程的支持。与在多任务操作系统中分叉外部进程不同，线程机制是
		由执行程序的单一进程中创建任务。这种方式的好处是对操作系统透明，这也是Java的设计目标。这样就能够移植到不支持多任务
		的操作系统（如Macintosh）。
			完整的仿真可能设计非常大量的任务，例如仿真中的每个元素都可以独立动作，包括门和岩石和各种人物事物。然而多线程系统
		对线程的数量是有限的，通常是几十到几百这样的数量级。这个数字依赖于平台、Java的版本，在Java中通常要假定你不会获得足
		够的线程来为仿真中的每个元素都提供一个线程，解决这个问题要通过“协作多线程”的方式。
			Java的线程机制是抢占式的，表示调度机制会周期地中断线程，将上下文切换到另一个线程，从而为每个线程都提供时间片，
		使得每个线程都会分配到合理的时间去执行它的任务。在协作式系统中，每个任务都会自动的放弃控制，要求程序员有意识地在每个
		任务中插入某种类型的让步语句。协作式系统的优势是双重的：上下文切换的开销通常比抢占式系统要低廉得多，并且对可以同时
		执行的线程数量在理论上没有任何限制。当你处理大量仿真元素时，这是理想的解决方案。但是，某些协作式系统并未涉及为可以在
		多个处理器之间分配任务，这就使得可能在多处理器的环境下，速度也得不到提升。
	
	基本的线程机制
		使用多线程机制，这些独立任务（称为子任务）中的每个都将由执行线程来驱动。一个线程就是在进程中的一个单一的顺序控制流，
		因此，单个进程可以拥有多个并发执行的任务，但是你的程序使得每个任务都好像有自己的CPU一样，其底层机制是CPU时间切分。
			使用线程机制是一种建立透明的，可扩展的程序的方法，如果程序运行太慢。为机器添加一个CPU就能很容易地加快程序的运行
		速度。多任务和多线程往往是多处理器系统的最合理的方式。
		
		实现Runnable接口，将类定义成任务。但是这样并不会有什么作用，需要将任务启动起来有两种方式：
			1、任务交给Thread
			2、使用Executor
				JDK5的concurrent包中的执行器（Executor）将为你管理Thread对象，从而简化了并发编程。Executor在客户端
			和任务执行之间提供了一个间接层；与客户端直接执行任务不同，这个中介对象将执行任务。Executor允许你管理异步任务
			的执行，而无须显式地管理线程的生命周期。Executor是目前启动任务的优选方式。
				FixedThreadPool使用了有限的线程集来执行所提交的任务。使用它可以一次性先执行代价高昂的线程分配，因而也可
			以限制线程的数量。这可以节省时间，因为不用为每个任务都固定地付出创建线程的开销。在事件驱动的系统中，需要线程的事
			件处理器，通过直接从Pool中获得线程，也可以尽快得到服务。而CachedThreadPool通常会创建与所需数量相同的线程，然
			后在它回收线程时停止创建新线程，因此它是合理的Executor的首选。只有当这种方式有问题的时候，才需要切换到
			FixedThreadPool。
				SingleThreadExecutor就像是线程数量为1的FixedThreadPool。这对于你希望在另一个线程中连续运行的任何事
			物（长期存活的任务）来说，都是很有用的，例如监听进入套接字连接的任务。它对于希望在线程中运行的短任务也同样很方
			便，例如更新本地或远程日志的小人物，或者是事件分发线程。如果向SingleThreadExecutor提交了多个任务，那么这些任
			务将排队，每个任务都会在下一个任务开始之前运行结束，所有任务将使用相同的线程。
			Callable：	
				Runnable是执行工作的独立任务，但是没有返回值，希望任务完成后返回一个值，可以实现Callable接口而不是
			Runnable接口JDK5中引入Callable是一种具有类型参数的泛型，它的泛型参数表示从call中返回的值，并且必须使
			用ExecutorService.submit方法调用它submit方法会产生Future对象，它用Callable返回结果的特定类型进行了参数
			化。你可以用isDone()方法来查询Future是否已经完成，当任务完成时，它具有一个结果，你可以调用get()方法来获取该
			结果。也可以不用isDone()进行检查就直接调用get()在这种情况下，get()将阻塞，直至结果准备就绪。你还可以在试图调
			用get()来获取结果之前，先调用具有超时的get(0，或者调用isDone()来查看任务是否完成。
			Sleep：
				影响任务应为的一种简单方法是调用sleep()，这将使任务终止执行给定的时间。SleepingTask的run方法会抛出异
			常，并且在run中被捕获，异常不能跨线程传播回main()，所以必须在本地处理所有在任务内部产生的异常。
				JDK5之后线程睡眠使用TimeUtil，TimeUtil还可以被用来执行转换。
				虽然这样能起到一定的控制任务执行的顺序，但是不能依赖于Sleep来控制，如果你需要控制任务执行的顺序，最好的方
			法是使用同步控制，或者在某些情况下，压根不使用线程，但是要编写自己的协作例程，这些例程将会按照指定的顺序在互相之
			前传递控制权。
			Priority：
				线程的优先级将该线程的重要性传递给调度器，调度器会倾向于让优先权高的线程先执行，但是优先权低的也会执行（优
			先权不会导致死锁），优先级较低的仅仅是执行频率较低而已。在绝大多数时间里，所有线程都应该以默认的优先级运行，试图
			操作线程的优先级通常是一种错误。 Thread.currentThread()打印出来的线程池-线程id，优先级，线程的出处尽
			管JDK有10个优先级，但是它与多数操作系统系统都不能映射得很好，例如windows有7个优先级且不是固定
			的，Sun的Solaries有2的31次方个优先级，唯一可移植的是当调整优先级的时，使用MAX_PRIORITY、NORM_PRIORITY、
			MIN_PRIORITY。
			Yield：
				yield方法仅仅是暗示调度器，你的工作已经做得差不多了，可以让别的线程使用CPU了。（这只是暗示，没有任何机制
			保证它将会被采纳）。当调用yield()时，只是建议具有相同优先级的其他线程可以运行。
			daemon thread（后台线程）：
				所谓后台（Daemon）线程，是指在程序运行的时候在后台提供一种通用服务的线程，并且这种线程并不属于程序中不可或
			缺的部分，因此，当所有的非后台线程结束时，程序也就终止了，同时会杀死进程中的所有后台线程，反过来说，只要有任何非
			后台线程还在运行，程序就不会终止。比如，执行main()就是一个非后台线程。后台进程在不执行finally子句的情况下就会
			终止run()方法。因为不能以一种优雅的方式关闭后台进程，所以使用Thread来创建进程不是一种好的思想。非后台
			的Executor通常是一种更好的方式，因为它控制的所有任务可以同时被关闭。在这种情况下，关闭将以有序的方式执行。
			编码的变体：
				ThreadVariations.java展示了创建线程的不同方式（使用内部类（匿名或者不匿名）、接口、方法）
			术语：
				要执行的任务和驱动它的线程之间有一个差异，你创建任务，并通过某种方式将一个线程附着在任务上，以使得这个线程
			可以驱动任务。所以任务跟线程实际上是两个概念。
			加入一个线程：
				如果某个线程在另一个线程t上调用t.join，此线程将被挂起，直到目标线程t结束才恢复也可以在join()的时候加上一
			个超时参数（单位是毫秒），这样如果目标线程在这段时间到期还没结束，join方法总能返回对join方法的调用可以被中
			断，做法是在调用线程上调用interrupt方法。
				注意，JDK5中的concurrent类库包含如CyclicBarrier这样的工具，可能比早期库中的join()更实用。
			线程组：
				线程组持有一个线程集合。线程组的价值在于其没多大价值
			捕获异常：
				由于线程的本质特性，使得你不能捕获从线程中逃逸的异常，异常一旦抛出，就到控制台去了，在JDK1.5之前，只能通过
			线程组来捕获这些异常，但是JDK1.5之后，Executor解决了这个问题。Thread.UncaughtExceptionHandler是JDK5的新
			接口，它允许你在每个Thread对象上附着一个异常处理器。Thread.UncaughtExceptionHandler.uncaughtException()
			会在线程因未捕获的异常而临近死亡时被调用。
			
			
# 总结：

	
