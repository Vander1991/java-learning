# 21-并发：
	前言：
		为并发的基本知识打下坚实的基础，从而能够理解其概念并编写出合理的多线程程序。
	
	并发的多面性：
		用并发解决的问题大体上可以分为“速度”和“设计可管理性”两种。
		更快的执行：
			并发通常是提高运行在单处理器上的程序的性能。在单处理器上运行的并发程序开销确实应该比该程序的所有部分都顺序执行的
		开销大，因为其中增加了所谓“上下文切换的代价”（从一个任务切换到另一个任务）。
			实现并发最直接的方式是在操作系统级别使用进程，进程是运行在它自己的地址空间内的自包容程序。多任务操作系统可以通过
		周期性地将CPU从一个进程切换到另一个进程来实现同时运行多个进程（程序），尽管它们总是歇歇停停的。操作系统一般会把进程
		隔离开。与此相反的是，像Java所使用的这种并发系统会共享诸如内存和I/O这样的资源，因此编写多线程程序最基本的困难在于在
		协调不同线程驱动的任务之间对这些资源的使用，以使得这些资源不会同时被多个任务访问。
			某些编程语言被设计为可以将并发任务彼此隔离，这些语言通常被称为函数型语言，其中每个函数调用都不会产生任何副作用，
		因此可以当做独立的任务来驱动（如Erlang）。
			Java采用更加传统的方式，在顺序性语言的基础上提供对线程的支持。与在多任务操作系统中分叉外部进程不同，线程机制是
		由执行程序的单一进程中创建任务。这种方式的好处是对操作系统透明，这也是Java的设计目标。这样就能够移植到不支持多任务
		的操作系统（如Macintosh）。
			完整的仿真可能设计非常大量的任务，例如仿真中的每个元素都可以独立动作，包括门和岩石和各种人物事物。然而多线程系统
		对线程的数量是有限的，通常是几十到几百这样的数量级。这个数字依赖于平台、Java的版本，在Java中通常要假定你不会获得足
		够的线程来为仿真中的每个元素都提供一个线程，解决这个问题要通过“协作多线程”的方式。
			Java的线程机制是抢占式的，表示调度机制会周期地中断线程，将上下文切换到另一个线程，从而为每个线程都提供时间片，
		使得每个线程都会分配到合理的时间去执行它的任务。在协作式系统中，每个任务都会自动的放弃控制，要求程序员有意识地在每个
		任务中插入某种类型的让步语句。协作式系统的优势是双重的：上下文切换的开销通常比抢占式系统要低廉得多，并且对可以同时
		执行的线程数量在理论上没有任何限制。当你处理大量仿真元素时，这是理想的解决方案。但是，某些协作式系统并未涉及为可以在
		多个处理器之间分配任务，这就使得可能在多处理器的环境下，速度也得不到提升。
	
	基本的线程机制
		使用多线程机制，这些独立任务（称为子任务）中的每个都将由执行线程来驱动。一个线程就是在进程中的一个单一的顺序控制流，
		因此，单个进程可以拥有多个并发执行的任务，但是你的程序使得每个任务都好像有自己的CPU一样，其底层机制是CPU时间切分。
			使用线程机制是一种建立透明的，可扩展的程序的方法，如果程序运行太慢。为机器添加一个CPU就能很容易地加快程序的运行
		速度。多任务和多线程往往是多处理器系统的最合理的方式。
		
		实现Runnable接口，将类定义成任务。但是这样并不会有什么作用，需要将任务启动起来有两种方式：
			1、任务交给Thread
			2、使用Executor
				JDK5的concurrent包中的执行器（Executor）将为你管理Thread对象，从而简化了并发编程。Executor在客户端
			和任务执行之间提供了一个间接层；与客户端直接执行任务不同，这个中介对象将执行任务。Executor允许你管理异步任务
			的执行，而无须显式地管理线程的生命周期。Executor是目前启动任务的优选方式。
				FixedThreadPool使用了有限的线程集来执行所提交的任务。使用它可以一次性先执行代价高昂的线程分配，因而也可
			以限制线程的数量。这可以节省时间，因为不用为每个任务都固定地付出创建线程的开销。在事件驱动的系统中，需要线程的事
			件处理器，通过直接从Pool中获得线程，也可以尽快得到服务。而CachedThreadPool通常会创建与所需数量相同的线程，然
			后在它回收线程时停止创建新线程，因此它是合理的Executor的首选。只有当这种方式有问题的时候，才需要切换到
			FixedThreadPool。
				SingleThreadExecutor就像是线程数量为1的FixedThreadPool。这对于你希望在另一个线程中连续运行的任何事
			物（长期存活的任务）来说，都是很有用的，例如监听进入套接字连接的任务。它对于希望在线程中运行的短任务也同样很方
			便，例如更新本地或远程日志的小人物，或者是事件分发线程。如果向SingleThreadExecutor提交了多个任务，那么这些任
			务将排队，每个任务都会在下一个任务开始之前运行结束，所有任务将使用相同的线程。
		Callable：	
			Runnable是执行工作的独立任务，但是没有返回值，希望任务完成后返回一个值，可以实现Callable接口而不是
		Runnable接口JDK5中引入Callable是一种具有类型参数的泛型，它的泛型参数表示从call中返回的值，并且必须使
		用ExecutorService.submit方法调用它submit方法会产生Future对象，它用Callable返回结果的特定类型进行了参数
		化。你可以用isDone()方法来查询Future是否已经完成，当任务完成时，它具有一个结果，你可以调用get()方法来获取该
		结果。也可以不用isDone()进行检查就直接调用get()在这种情况下，get()将阻塞，直至结果准备就绪。你还可以在试图调
		用get()来获取结果之前，先调用具有超时的get(0，或者调用isDone()来查看任务是否完成。
		Sleep：
			影响任务应为的一种简单方法是调用sleep()，这将使任务终止执行给定的时间。SleepingTask的run方法会抛出异
		常，并且在run中被捕获，异常不能跨线程传播回main()，所以必须在本地处理所有在任务内部产生的异常。
			JDK5之后线程睡眠使用TimeUtil，TimeUtil还可以被用来执行转换。
			虽然这样能起到一定的控制任务执行的顺序，但是不能依赖于Sleep来控制，如果你需要控制任务执行的顺序，最好的方
		法是使用同步控制，或者在某些情况下，压根不使用线程，但是要编写自己的协作例程，这些例程将会按照指定的顺序在互相之
		前传递控制权。
		Priority：
			线程的优先级将该线程的重要性传递给调度器，调度器会倾向于让优先权高的线程先执行，但是优先权低的也会执行（优
		先权不会导致死锁），优先级较低的仅仅是执行频率较低而已。在绝大多数时间里，所有线程都应该以默认的优先级运行，试图
		操作线程的优先级通常是一种错误。 Thread.currentThread()打印出来的线程池-线程id，优先级，线程的出处尽
		管JDK有10个优先级，但是它与多数操作系统系统都不能映射得很好，例如windows有7个优先级且不是固定
		的，Sun的Solaries有2的31次方个优先级，唯一可移植的是当调整优先级的时，使用MAX_PRIORITY、NORM_PRIORITY、
		MIN_PRIORITY。
		Yield：
			yield方法仅仅是暗示调度器，你的工作已经做得差不多了，可以让别的线程使用CPU了。（这只是暗示，没有任何机制
		保证它将会被采纳）。当调用yield()时，只是建议具有相同优先级的其他线程可以运行。
		daemon thread（后台线程）：
			所谓后台（Daemon）线程，是指在程序运行的时候在后台提供一种通用服务的线程，并且这种线程并不属于程序中不可或
		缺的部分，因此，当所有的非后台线程结束时，程序也就终止了，同时会杀死进程中的所有后台线程，反过来说，只要有任何非
		后台线程还在运行，程序就不会终止。比如，执行main()就是一个非后台线程。后台进程在不执行finally子句的情况下就会
		终止run()方法。因为不能以一种优雅的方式关闭后台进程，所以使用Thread来创建进程不是一种好的思想。非后台
		的Executor通常是一种更好的方式，因为它控制的所有任务可以同时被关闭。在这种情况下，关闭将以有序的方式执行。
		编码的变体：
			ThreadVariations.java展示了创建线程的不同方式（使用内部类（匿名或者不匿名）、接口、方法）
		术语：
			要执行的任务和驱动它的线程之间有一个差异，你创建任务，并通过某种方式将一个线程附着在任务上，以使得这个线程
		可以驱动任务。所以任务跟线程实际上是两个概念。
		加入一个线程：
			如果某个线程在另一个线程t上调用t.join，此线程将被挂起，直到目标线程t结束才恢复也可以在join()的时候加上一
		个超时参数（单位是毫秒），这样如果目标线程在这段时间到期还没结束，join方法总能返回对join方法的调用可以被中
		断，做法是在调用线程上调用interrupt方法。
			注意，JDK5中的concurrent类库包含如CyclicBarrier这样的工具，可能比早期库中的join()更实用。
		线程组：
			线程组持有一个线程集合。线程组的价值在于其没多大价值
		捕获异常：
			由于线程的本质特性，使得你不能捕获从线程中逃逸的异常，异常一旦抛出，就到控制台去了，在JDK1.5之前，只能通过
		线程组来捕获这些异常，但是JDK1.5之后，Executor解决了这个问题。Thread.UncaughtExceptionHandler是JDK5的新
		接口，它允许你在每个Thread对象上附着一个异常处理器。Thread.UncaughtExceptionHandler.uncaughtException()
		会在线程因未捕获的异常而临近死亡时被调用。
	
	共享受限资源
		不正确地访问资源
			注意到递增程序自身需要多个步骤，并且在递增过程中的任务可以被线程机制挂起，也就是说Java中，递增不是原子性的操
		作，因此，如果不保护任务，即使单一的递增也不是安全的。（具体例子看szu.vander.resourceshare.error）
		解决共享资源竞争
		
		解决共享资源竞争
			对于并发工作，需要某种方式来防止两个任务访问相同的资源，至少在关键阶段不能出现这种情况。
			防止这种冲突的方法就是当资源被一个任务使用时，在其上加锁，第一个访问某资源的任务必须锁定这项资源，使其它任务在
		其被解锁前无法访问他，而在其被解锁之时，另一个任务就可以锁定并使用它，以此类推。基本上所有的并发模式在解决线程冲突
		问题的时候，都是采用序列化访问共享资源的方案。这意味着在给定时刻只允许一个任务访问共享资源。通常是通过在代码前面加
		上一条锁语句来实现的，这就使得在一段时间内只有一个任务可以运行这段代码。因为锁语句产生一种互相排斥的效果，所以这种
		机制常常成为互斥量。
			Java提供关键字synchronized的形式，防止资源冲突提供了内置的支持。当任务要执行被synchronize关键字保护的代码
		片段的时候，它将检查锁是否可用，然后获取锁，执行代码，释放锁。共享资源一般以对象形式存在的内存片段，但也可以是文件、
		输入/输出端口，或者是打印机。要控制对共享资源的访问，得先把它包装进一个对象。然后把所有要访问这个资源的方法标记为
		synchronized。如果某个任务处于一个对标记为synchronized的方法的调用中，那个在这个线程从该方法返回之前，其他所有
		要调用类中的任何标记为synchronized方法的线程都会被阻塞。类的数据成员都应该声明为private。而且只能通过方法来访问
		这些数据；可以把昂发标记为synchronized来防止资源冲突。
			下面是声明synchronize方法的方式：
				synchronized void f() {...}
				synchronized void g() {...}
			所有对象都自动含有单一的锁（也成为监视器）。当在对象上调用其任意synchronized方法的时候，此对象都被加锁，这时
		该对象上的其他synchronized方法只有等到前一个方法调用完毕并释放了锁之后才能被调用。对于前面的方法，如果某个任务对
		对象调用了f()，对于同一个对象而言，只能等到f()调用结束并释放了锁之后没其他任务才能调用f()和g()。所以对于某个特定
		对象来说，其所有synchronized方法共享同一个锁，这可以被用来防止多个任务同时访问被编码为对象内存。
			注意，在使用并发时，将域设置为private很重要，否则，synchronized关键字不能防止其他任务直接访问域，这样就会
		造成冲突。
		一个任务可以多次获得对象的锁：如果一个方法在同一个对象上调用了第二个方法，后者有调用了同一个对象那个的另一个方法，
		就会发生这种情况。JVM扶着跟踪对象被加锁的次数，如果一个对象被解锁（即锁被完全释放），其计数变为0。在任务第一次给对
		象加锁的时候，计数变为1。每当这个相同的任务在这个对象上获得锁时，计数都会递增，只有首先获得了锁的任务才能允许继续获
		取多个锁。每当任务离开一个synchronized方法，计数递减，当计数为零时，锁被完全释放，此时别的任务就可以使用此资源了。
			针对每个类，也有一个锁（作为类的Class对象的一部分），所以synchronized static方法可以在类的访问内防止对
		static数据的并发访问。
			应该什么时候同步？
			运用Brian同步规则：
				如果你正在写一个变量，它可能接下来将被另一个线程读取，或者正在读取一个上一次已经被另一个线程写过的变量，
			那么你必须使用同步，并且，读写线程都必须用相同的监视器锁同步。	如果在你的类中有超过一个方法在处理临界数据，那么
			你必须同步所有相关的方法。如果只同步一个方法，那么其他方法将会随意地忽略对象锁，并可以在无任何惩罚的情况下被调用。
			重要的一点：每个访问临界共享资源的方法都必须被同步，否则它们就不会正确地工作。
		使用显式地Lock：
			JDK1.5的concurrent类库包含定义在java.util.concurrent.locks中的显式地互斥机制。Lock对象必须被显式地创建、
		锁定和释放。因此它与内建的锁形式相比，代码缺乏优雅性，但是对于解决某些类型的问题，它更加灵活。可以指定对一个函数中的一
		部分加锁，然后在某个部分又把锁释放掉，详见MutexEvenGenerator.java。
			使用锁的好处，一个是灵活，另一个是如果在使用synchronized关键字时，某些事物失败了，会直接抛出异常，这样就没机会
		去做任何清理工作，以维护系统使其良好地运行，使用了显式地Lock对象，就可以使用finally字句将系统维护在正确的状态了。
			大体上，使用synchronized时，需要写的代码更少，并且用户错误出现的可能性也降低，因此通常只有在解决特殊问题时，
		才使用显式地Lock对象。例如，用synchronized关键字不能尝试获取锁且如果获取失败还可以过会尝试重新获取，实在获取不
		到才放弃获取，要实现这些，就得用lock了，详见AttemptingLocking.java。显式的Lock对象再加锁和释放锁方面，相对于内
		建的synchronized锁来说，还赋予了你更细粒度的控制力。这对于实现专有同步结构是很有用，例如用于遍历链表中的节点的节传
		递的加锁机制（也称为锁耦合），这种遍历代码必须在释放当前节点的锁之前捕获下一个节点的锁。
		
		原子性与易变性
			原子性：	
				有关Java线程的讨论中，经常有个不正确的说法，就是“原子操作不需要进行同步控制。原子操作是不能被线程调度机制
			中断的操作；一旦操作开始，那么它一定可以在可能发生的上下文切换之前执行完毕”。实际上并不是这样的，依赖原子性来解
			决并发问题的后果可能很严重，在java.util.concurrent类库中利用原子性已经实现了某些巧妙的组件。
				原子性可以应用于除long和double之外的所有基本类型之上的“简单操作”。对于读取和写入除long和double之外的基
			本类型变量来说，可以保证它们是不可分原子的操作来操作内存。但是JVM可以将64位（long和double变量）的读取和写入当
			做两个分离的32位操作来执行，这就产生了在一个读取和写入操作中间发生上下文切换，从而导致不同的任务可以看到不正确结
			果的可能性（这有时称为字撕裂，因为你可能会看到部分被修改过的数值）。但是，当你定义long或double变量时，如果使用
			volatile关键字，就会获得（简单的赋值与返回操作的）原子性。不同的JVM可以任意地提供更强的保证，但是不能依赖平台
			相关的特性。
				因此原子操作可由线程机制来保证其不可中断，专家级的程序员可以利用这点来编写无锁的代码，这些代码不需要被同步。
			但是如果不具备用原子操作来替换同步的能力，这么做了可能会引发很多意想不到的问题。
			什么样的操作是原子的呢？
				在c++中，i++,i=i+2这样的操作可能都是一条指令搞定，但是在java中，这样的操作则需要先getfield然后再
			putfield，所以就可能在i++期间，被不同的线程获取到不同的结果（获取到还没有加完的结果）。
			可视性：
				在多处理器系统上，相对于单处理器系统，可视性的问题比原子性问题多得多，一个任务作出的修改，即使在不中断的意
			义上讲是原子性的，对其他任务也可能是不可视的（例如，修改的知识暂时性地存储在本地处理器的缓存中），因此不同的任务
			对应用的状态有不同的视图。而同步机制强制在处理器系统中，一个任务作出的修改必须在应用中是可视的。如果没有同步机制，
			那么修改时可视将无法确定。
				volatile还确保了应用中的可视性，如果一个域声明为volatile，那么只要对这个域产生了写操作，那么所有读操作都
			能看到这个修改。即使使用了本地缓存，情况也都一样。volatile域会立即被写入到主存中，而读取操作就发生在主存中。如果
			多个任务同时访问某个域，那么这个域就应该是volatile的，否则，这个域应该只能经由同步来访问，同步也会导致向主存中
			刷新，因此如果一个域完全有synchronized来防护就不必设为volatile（-不稳定性）。
				一个任务所做的任何写入操作对这个任务来说都是可视的，因此如果它只需要在这个任务内部可视，那么你就不需要将其设
			置为volatile。（就是说只有在多线程访问同一资源的时候才考虑这个关键字）
				当一个域的值依赖于它之前的值时（例如递增操作），volatile就无法工作了，如果某个域的值受到其他域的值得限制，那
			么volatile也无法工作，例如Range类的lower和upper边界就必须遵循lower<=upper的限制。使用volatile而不是
			synchronized的唯一安全情况是类中只有一个可变的域，再次提醒第一选择使用synchronized关键字，这是最安全的方式，
			而尝试其他方式都是有风险的。
				如果一个域可能会被多个任务同时访问或者这些任务重至少有一个是写入任务，那么你就应该将这个域设置为volatile的，
			如果将一个域定义为volatile，那么它就会告诉编译器不要执行任何一处读取和写入操作的优化，这些操作的目的是用线程中的
			局部变量维护对这个域的精确同步，实际上，读取和写入都是直接针对内存的，而没有被缓存，但是volatile并不能递增不是原
			子性操作这一事实产生影响。
				volatile有两个功能：
					1、通过告诉编译器读取和写入操作不要进行优化，别使用缓存，来实现消除可视性的问题
					2、使用volatile可以获得一定程度的原子性（如long或double的简单赋值和返回操作）
	
		原子类
			JDK1.5中引入了AtomicInteger、AtomicLong、AtomicReference等特殊的原子性变量类，它们提供下面形式的原子性条
		件更新操作：boolean compareAndSet(expectedValue, updateValue)；这些类被吊证为可以使用在某些现代处理器的可获
		得的，并且是在机器级别上的原子性，因此使用它们就可以放心，对于一般编程很少用到，但是性能调优的时候很有用。
			
		临界区
			如果希望防止多个线程同时访问方法内部的部分代码而不是防止访问整个方法，通过这种方式分离出来的代码段被称为临界区（critical 
		section），它也使用synchronized建立。在这里synchronized被用来指定某个对象，此对象的锁被用来对花括号内的代码进行同步
		控制：
			synchronized(syncObject) {
				//这部分的代码在某个时刻只能允许一个任务执行
			}
			这也被称为同步控制块，在进入此代码段前，必须得到syncObject对象的锁。如果其他线程已经得到这个锁，那么就得等到锁被释放之后，
		才能进入临界区。通过使用同步控制块，而不是对整个方法进行同步控制，可以使得多个任务访问对象的时间性能得到显著提高。具体看Critical
		Section类。	
			同步控制块相较于对整个方法进行同步的有点在于，可以在安全的情况下让其他线程尽可能多的访问，因为同步控制块只是同步方法中的一部分
		代码。
		
		在其他对象上同步
			synchronized块必须给定一个在其上进行同步的对象，并且最合理的方式是，使用其方法正在被调用的当前对象：synchronized(this)
		这正是PairManager2所使用的方式。同步对象想较于同步代码来说，同步对象是锁对象，相当于每new一个对象某个时刻只能被一个线程运行，但是
		同步代码就是仅仅针对代码段而言的，一个同步的代码段某个时刻只能被一个线程执行。
		
		线程本地存储
			防止任务在共享资源上产生冲突的第二种方式是根除对变量的共享，线程本地存储可以为使用相同变量的每个不同的线程都创建不同的存储。如果
		有5个线程都要使用变量所表示的对象，那线程本地存储就会生成5个用于x的不同的存储块。创建和管理线程本地存储可以由java.lang.ThreadLocal
		类来实现。
	
	终结任务
		cancel()与isCancel()方法一个用来终结线程，一个用来判断线程是否已经终结。
		
		装饰性花园
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
		
				
			
			
# 总结：

	
